// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClusterAPIArgs {
    address?: pulumi.Input<string>;
    externalAddress?: pulumi.Input<string>;
    extraArgs?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    k0sApiPort?: pulumi.Input<number>;
    port?: pulumi.Input<number>;
    sans?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterCalicoArgs {
    envVars?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    flexVolumeDriverPath?: pulumi.Input<string>;
    ipAutodetectionMethod?: pulumi.Input<string>;
    mode?: pulumi.Input<string>;
    mtu?: pulumi.Input<number>;
    overlay?: pulumi.Input<string>;
    vxlanPort?: pulumi.Input<number>;
    vxlanVNI?: pulumi.Input<number>;
    wireguard?: pulumi.Input<boolean>;
}

export interface ClusterCalicoImageArgs {
    cni?: pulumi.Input<inputs.ClusterImageArgs>;
    flexvolume?: pulumi.Input<inputs.ClusterImageArgs>;
    kubecontrollers?: pulumi.Input<inputs.ClusterImageArgs>;
    node?: pulumi.Input<inputs.ClusterImageArgs>;
}

export interface ClusterControllerManagerArgs {
    extraArgs?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterDualStackArgs {
    IPv6podCIDR?: pulumi.Input<string>;
    IPv6serviceCIDR?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterEnvoyProxyArgs {
    apiServerBindPort?: pulumi.Input<number>;
    image?: pulumi.Input<string>;
    imagePullPolicy?: pulumi.Input<string>;
    konnectivityServerBindPort?: pulumi.Input<number>;
}

export interface ClusterEtcdArgs {
    externalCluster?: pulumi.Input<inputs.ClusterEtcdExternalClusterArgs>;
    extraArgs?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    peerAddress?: pulumi.Input<string>;
}

export interface ClusterEtcdExternalClusterArgs {
    ca?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    endpoints: pulumi.Input<pulumi.Input<string>[]>;
    etcdPrefix?: pulumi.Input<string>;
}

export interface ClusterFeatureGateArgs {
    components?: pulumi.Input<pulumi.Input<string>[]>;
    enabled?: pulumi.Input<boolean>;
    name: pulumi.Input<string>;
}

export interface ClusterFileArgs {
    dirPerm?: pulumi.Input<string>;
    dst?: pulumi.Input<string>;
    dstDir?: pulumi.Input<string>;
    group?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    perm?: pulumi.Input<string>;
    src?: pulumi.Input<string>;
    user?: pulumi.Input<string>;
}

export interface ClusterHookArgs {
    after?: pulumi.Input<pulumi.Input<string>[]>;
    before?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterHooksArgs {
    apply?: pulumi.Input<inputs.ClusterHookArgs>;
    backup?: pulumi.Input<inputs.ClusterHookArgs>;
    reset?: pulumi.Input<inputs.ClusterHookArgs>;
}

export interface ClusterHostArgs {
    environment?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    files?: pulumi.Input<pulumi.Input<inputs.ClusterFileArgs>[]>;
    hooks?: pulumi.Input<inputs.ClusterHooksArgs>;
    hostname?: pulumi.Input<string>;
    installFlags?: pulumi.Input<pulumi.Input<string>[]>;
    k0sBinaryPath?: pulumi.Input<string>;
    localhost?: pulumi.Input<inputs.ClusterLocalhostArgs>;
    noTaints?: pulumi.Input<boolean>;
    os?: pulumi.Input<string>;
    privateAddress?: pulumi.Input<string>;
    privateInterface?: pulumi.Input<string>;
    role: pulumi.Input<string>;
    ssh?: pulumi.Input<inputs.ClusterSSHArgs>;
    uploadBinary?: pulumi.Input<boolean>;
    winRM?: pulumi.Input<inputs.ClusterWinRMArgs>;
}

export interface ClusterImageArgs {
    image?: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface ClusterImagesArgs {
    calico?: pulumi.Input<inputs.ClusterCalicoImageArgs>;
    coredns?: pulumi.Input<inputs.ClusterImageArgs>;
    default_pull_policy?: pulumi.Input<string>;
    konnectivity?: pulumi.Input<inputs.ClusterImageArgs>;
    kubeproxy?: pulumi.Input<inputs.ClusterImageArgs>;
    kuberouter?: pulumi.Input<inputs.ClusterKubeRouterImageArgs>;
    metricsserver?: pulumi.Input<inputs.ClusterImageArgs>;
    pause?: pulumi.Input<inputs.ClusterImageArgs>;
    repository?: pulumi.Input<string>;
}

export interface ClusterInstallConfigArgs {
    users?: pulumi.Input<inputs.ClusterInstallConfigUserArgs>;
}

export interface ClusterInstallConfigUserArgs {
    etcdUser?: pulumi.Input<string>;
    kineUser?: pulumi.Input<string>;
    konnectivityUser?: pulumi.Input<string>;
    kubeAPIserverUser?: pulumi.Input<string>;
    kubeSchedulerUser?: pulumi.Input<string>;
}

export interface ClusterK0sArgs {
    config?: pulumi.Input<inputs.ClusterK0sConfigArgs>;
    dynamicConfig?: pulumi.Input<boolean>;
    version?: pulumi.Input<string>;
    versionChannel?: pulumi.Input<string>;
}

export interface ClusterK0sConfigArgs {
    metadata?: pulumi.Input<inputs.ClusterMetadataArgs>;
    spec?: pulumi.Input<inputs.ClusterK0sSpecArgs>;
}

export interface ClusterK0sSpecArgs {
    api?: pulumi.Input<inputs.ClusterAPIArgs>;
    controllerManager?: pulumi.Input<inputs.ClusterControllerManagerArgs>;
    featureGates?: pulumi.Input<pulumi.Input<inputs.ClusterFeatureGateArgs>[]>;
    images?: pulumi.Input<inputs.ClusterImagesArgs>;
    installConfig?: pulumi.Input<inputs.ClusterInstallConfigArgs>;
    konnectivity?: pulumi.Input<inputs.ClusterKonnectivityArgs>;
    network?: pulumi.Input<inputs.ClusterNetworkArgs>;
    podSecurityPolicy?: pulumi.Input<inputs.ClusterPodSecurityPolicyArgs>;
    scheduler?: pulumi.Input<inputs.ClusterSchedulerArgs>;
    storage?: pulumi.Input<inputs.ClusterStorageArgs>;
    telemetry?: pulumi.Input<inputs.ClusterTelemetryArgs>;
    workerProfiles?: pulumi.Input<pulumi.Input<inputs.ClusterWorkerProfileArgs>[]>;
}

export interface ClusterKineArgs {
    dataSource: pulumi.Input<string>;
}

export interface ClusterKonnectivityArgs {
    adminPort?: pulumi.Input<number>;
    agentPort?: pulumi.Input<number>;
}

export interface ClusterKubeProxyArgs {
    disabled?: pulumi.Input<boolean>;
    iptables?: pulumi.Input<inputs.ClusterKubeProxyIPTablesArgs>;
    ipvs?: pulumi.Input<inputs.ClusterKubeProxyIPVSArgs>;
    mode?: pulumi.Input<string>;
    nodePortAddresses?: pulumi.Input<string>;
}

export interface ClusterKubeProxyIPTablesArgs {
    masqueradeAll?: pulumi.Input<boolean>;
    masqueradeBit?: pulumi.Input<number>;
    minSyncPeriod?: pulumi.Input<string>;
    syncPeriod?: pulumi.Input<string>;
}

export interface ClusterKubeProxyIPVSArgs {
    excludeCIDRs?: pulumi.Input<string>;
    minSyncPeriod?: pulumi.Input<string>;
    scheduler?: pulumi.Input<string>;
    strictARP?: pulumi.Input<boolean>;
    syncPeriod?: pulumi.Input<string>;
    tcpFinTimeout?: pulumi.Input<string>;
    tcpTimeout?: pulumi.Input<string>;
    udpTimeout?: pulumi.Input<string>;
}

export interface ClusterKubeRouterArgs {
    autoMTU?: pulumi.Input<boolean>;
    extraArgs?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    hairpin?: pulumi.Input<string>;
    ipMasq?: pulumi.Input<boolean>;
    metricsPort?: pulumi.Input<number>;
    mtu?: pulumi.Input<number>;
}

export interface ClusterKubeRouterImageArgs {
    cni?: pulumi.Input<inputs.ClusterImageArgs>;
    cniInstaller?: pulumi.Input<inputs.ClusterImageArgs>;
}

export interface ClusterLocalhostArgs {
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterMetadataArgs {
    name: pulumi.Input<string>;
}

export interface ClusterNetworkArgs {
    calico?: pulumi.Input<inputs.ClusterCalicoArgs>;
    clusterDomain?: pulumi.Input<string>;
    dualStack?: pulumi.Input<inputs.ClusterDualStackArgs>;
    kubeProxy?: pulumi.Input<inputs.ClusterKubeProxyArgs>;
    kuberouter?: pulumi.Input<inputs.ClusterKubeRouterArgs>;
    nodeLocalLoadBalancing?: pulumi.Input<inputs.ClusterNodeLocalLoadBalancingArgs>;
    podCIDR?: pulumi.Input<string>;
    provider?: pulumi.Input<string>;
    serviceCIDR?: pulumi.Input<string>;
}

export interface ClusterNodeLocalLoadBalancingArgs {
    enabled?: pulumi.Input<boolean>;
    envoyProxy?: pulumi.Input<inputs.ClusterEnvoyProxyArgs>;
    type?: pulumi.Input<string>;
}

export interface ClusterPodSecurityPolicyArgs {
    defaultPolicy?: pulumi.Input<string>;
}

export interface ClusterSSHArgs {
    address: pulumi.Input<string>;
    bastion?: pulumi.Input<inputs.ClusterSSHArgs>;
    hostKey?: pulumi.Input<string>;
    key?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    user?: pulumi.Input<string>;
}

export interface ClusterSchedulerArgs {
    extraArgs?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterSpecArgs {
    hosts: pulumi.Input<pulumi.Input<inputs.ClusterHostArgs>[]>;
    k0s?: pulumi.Input<inputs.ClusterK0sArgs>;
}

export interface ClusterStorageArgs {
    etcd?: pulumi.Input<inputs.ClusterEtcdArgs>;
    kine?: pulumi.Input<inputs.ClusterKineArgs>;
    type?: pulumi.Input<string>;
}

export interface ClusterTelemetryArgs {
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterWinRMArgs {
    address: pulumi.Input<string>;
    bastion?: pulumi.Input<inputs.ClusterSSHArgs>;
    caCert?: pulumi.Input<string>;
    cert?: pulumi.Input<string>;
    insecure?: pulumi.Input<boolean>;
    key?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    tlsServerName?: pulumi.Input<string>;
    useHTTPS?: pulumi.Input<boolean>;
    useNTLM?: pulumi.Input<boolean>;
    user?: pulumi.Input<string>;
}

export interface ClusterWorkerProfileArgs {
    name: pulumi.Input<string>;
    values: pulumi.Input<{[key: string]: any}>;
}
